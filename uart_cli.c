/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
 */

#include <stdio.h>
#include <string.h>

#include "project.h"

#include <FreeRTOS.h>
#include <task.h>
#include <semphr.h>

/* FreeRTOS+FAT includes. */
#include "ff_headers.h"
#include "ff_sddisk.h"
#include "ff_stdio.h"

#include "FreeRTOS_CLI.h"
#include "uart_cli.h"
#include "rtc.h"
#include "hw_config.h"

/*
 * Register commands that can be used with FreeRTOS+CLI.
 * The commands are defined in CLI-commands.c and File-related-CLI-commands.c
 * respectively.
 */
extern void vRegisterFileSystemCLICommands(void);

bool die_now = false; // Used outside here

static SemaphoreHandle_t xReceiveSemaphore;

void _putchar(char character) {
	while (!printf("%c", character));
}

static void ISR_UART() {    
    /* Check for "RX fifo not empty interrupt" */
    if((UART_1_HW->INTR_RX_MASKED & SCB_INTR_RX_MASKED_NOT_EMPTY_Msk ) != 0)
	{
        /* Clear UART "RX fifo not empty interrupt" */
        // Note: RW1C
		//UART_1_HW->INTR_RX = UART_1_HW->INTR_RX & SCB_INTR_RX_NOT_EMPTY_Msk;   
        Cy_SCB_ClearRxInterrupt(UART_1_HW, SCB_INTR_RX_NOT_EMPTY_Msk);

        /* Mask the RX fifo not empty interrupt bit */
        //UART_1_HW->INTR_RX_MASK = 0;
        Cy_SCB_SetRxInterruptMask(UART_1_HW, 0);


		/* The xHigherPriorityTaskWoken parameter must be initialized to pdFALSE as
		 it will get set to pdTRUE inside the interrupt safe API function if a
		 context switch is required. */
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;

		configASSERT(xReceiveSemaphore);

        // Ignoring return code because it's OK if it's already given
		xSemaphoreGiveFromISR(xReceiveSemaphore, &xHigherPriorityTaskWoken);

		/* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR(). If
		 xHigherPriorityTaskWoken was set to pdTRUE inside vTaskNotifyGiveFromISR()
		 then calling portYIELD_FROM_ISR() will request a context switch. If
		 xHigherPriorityTaskWoken is still pdFALSE then calling
		 portYIELD_FROM_ISR() will have no effect. */
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

// uartTask - the function which handles input from the UART
// Note:
//   This initially used Task Notifications, 
//   but that caused a conflict with filesystem calls that also use Task Notifications.
static void UARTTask(void *arg) {
	(void) arg;

	size_t cInputIndex = 0;
	static char cOutputString[cmdMAX_OUTPUT_SIZE] = { 0 };
	static char cInputString[cmdMAX_INPUT_SIZE] = { 0 };
	BaseType_t xMoreDataToFollow = 0;
	bool in_overflow = false;

	for (;;) {
		uint32_t cRxedChar;

        if (!UART_1_GetNumInRxFifo()) {
		// Wait for interrupt:
		// BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );
    		BaseType_t xStatus = xSemaphoreTake(xReceiveSemaphore, portMAX_DELAY);
		configASSERT(xStatus == pdPASS);
        }
        while (UART_1_GetNumInRxFifo()) { 

            /* Get the character from terminal */
		    cRxedChar = UART_1_Get();
            configASSERT(CY_SCB_UART_RX_NO_DATA != cRxedChar);

			UART_1_Put(cRxedChar); // echo

			/* Newline characters are taken as the end of the command
			 string. */
			if (cRxedChar == '\n' || cRxedChar == '\r') {

				in_overflow = false;

				TickType_t xStart = 0;
				/* Just to space the output from the input. */
				UART_1_Put('\n');

				if (!strnlen(cInputString, sizeof cInputString)) { // Empty input
					UART_1_PutString(pcEndOfOutputMessage);
					continue;
				}
				const char timestr[] = "time ";
				if (0 == strncmp(cInputString, timestr, 5)) {
					xStart = xTaskGetTickCount();
					char tmp[cmdMAX_INPUT_SIZE] = { 0 };
					strlcpy(tmp, cInputString + 5, sizeof tmp);
					strlcpy(cInputString, tmp, cmdMAX_INPUT_SIZE);
				}
				/* Process the input string received prior to the
				 newline. */
				do {
					/* Pass the string to FreeRTOS+CLI. */
					cOutputString[0] = 0x00;
					xMoreDataToFollow = FreeRTOS_CLIProcessCommand(cInputString, cOutputString,
							cmdMAX_OUTPUT_SIZE);

					/* Send the output generated by the command's
					 implementation. */
					UART_1_PutString(cOutputString);

					/* Until the command does not generate any more output. */
				} while (xMoreDataToFollow);

				if (xStart) {
					printf("Time: %lu s\n",
							(unsigned long) (xTaskGetTickCount() - xStart)
									/ configTICK_RATE_HZ);
				}
				/* All the strings generated by the command processing
				 have been sent.  Clear the input string ready to receive
				 the next command.  */
				cInputIndex = 0;
				memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);

				/* Transmit a spacer to make the console easier to
				 read. */
				printf("%s", pcEndOfOutputMessage);
                fflush(stdout);

			} else { // Not newline

				if (in_overflow)
					continue;

				if ((cRxedChar == '\b') || (cRxedChar == cmdASCII_DEL)) {
					/* Backspace was pressed.  Erase the last character
					 in the string - if any. */
					if (cInputIndex > 0) {
						cInputIndex--;
						cInputString[(int) cInputIndex] = '\0';
					}
				} else {
					/* A character was entered.  Add it to the string
					 entered so far.  When a \n is entered the complete
					 string will be passed to the command interpreter. */
					if (cInputIndex < cmdMAX_INPUT_SIZE - 1) {
						cInputString[(int) cInputIndex] = cRxedChar;
						cInputIndex++;
					} else {
						printf("\a[Input overflow!]\n");
                        fflush(stdout);                        
						memset(cInputString, 0, sizeof(cInputString));
						cInputIndex = 0;
						in_overflow = true;
					}
				}
			}
		}; // while (UART_1_GetNumInRxFifo())
        
        /* 
        Note: To avoid being triggered by events from previous transactions, 
        whenever the firmware enables an interrupt mask register bit, 
        it should clear the interrupt request register in advance.
          -- CY8C63x6, CY8C63x7 Architecture TRM
        */
        
        /* Clear UART "RX fifo not empty interrupt" */
        // From PSoC 6 MCU: CY8C61x6, CY8C61x7 Registers TRM: NOT_EMPTY: RW1C
		UART_1_HW->INTR_RX = SCB_INTR_RX_NOT_EMPTY_Msk;                

        /* Unmasking only the RX fifo not empty interrupt bit */
        UART_1_HW->INTR_RX_MASK = SCB_INTR_RX_MASK_NOT_EMPTY_Msk;
	}
}

/*-----------------------------------------------------------*/
static BaseType_t diskInfo(char *pcWriteBuffer, size_t xWriteBufferLen,
		const char *pcCommandString) {
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;
	const char *pcParameter;
	BaseType_t xParameterStringLength;

	/* Obtain the parameter string. */
	pcParameter = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
		1, /* Return the first parameter. */
		&xParameterStringLength /* Store the parameter string length. */
	);

	/* Sanity check something was returned. */
	configASSERT(pcParameter);

    sd_card_t *sd = sd_get_by_name(pcParameter);
    size_t i;
    for (i = 0; i < sd->ff_disk_count; ++i) {
    	FF_Disk_t *pxDisk = sd->ff_disks[i];
		if (pxDisk) {
            FF_SDDiskShowPartition(pxDisk);
        }
    }
    return pdFALSE;
}
static const CLI_Command_Definition_t xDiskInfo = { 
		"diskinfo", /* The command string to type. */
		"\ndiskinfo <device name>:\n Print information about mounted partitions\n"
		"\te.g.: \"diskinfo SDCard\"\n", 
		diskInfo, /* The function to run. */
		1 /* One parameter is expected. */
};/*-----------------------------------------------------------*/
static BaseType_t die_fn(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

	die_now = true;

	return pdFALSE;
}
static const CLI_Command_Definition_t xDie = { 
    "die", /* The command string to type. */
    "\ndie:\n Kill background tasks\n", 
    die_fn, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/
static BaseType_t unDie(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

	die_now = false;

	return pdFALSE;
}
static const CLI_Command_Definition_t xUnDie = { 
    "undie", /* The command string to type. */
    "\nundie:\n Allow background tasks to live again\n", 
    unDie, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/
static BaseType_t setrtc(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;
	BaseType_t xParameterStringLength;

	const char *secStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	6, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(secStr);

	const char *minStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	5, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(minStr);

	const char *hourStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	4, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(hourStr);

	const char *yearStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	3, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(yearStr);

	const char *monthStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	2, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(monthStr);

	const char *dateStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	1, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(dateStr);

	SetDateTime(dateStr, monthStr, yearStr, secStr, minStr, hourStr);

	return pdFALSE;
}
static const CLI_Command_Definition_t xSetRTC = { 
    "setrtc", /* The command string to type. */
    "\nsetrtc <DD> <MM> <YY> <hh> <mm> <ss>:\n"
        "\tSet Real Time Clock\n"
		"\tParameters: new date (DD MM YY) new time in 24-hour format (hh mm ss)\n", 
    setrtc, /* The function to run. */
    6 /* parameters are expected. */
};
/*-----------------------------------------------------------*/
static void printDateTime() {
    char buf[128] = {0};    

//	PrintDateTime();
    
	time_t epoch_secs = FreeRTOS_time(NULL);
	struct tm *ptm = localtime(&epoch_secs);    
    size_t n = strftime(buf, sizeof(buf), "%c", ptm);    
	configASSERT(n); 
    printf("%s\n", buf);
	strftime(buf, sizeof(buf), "%j", ptm);    //The day of the year as a decimal number (range 001 to 366).
    printf("Day of year: %s\n", buf);    
}
static BaseType_t date(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

    printDateTime();

	return pdFALSE;
}
static const CLI_Command_Definition_t xDate = { 
    "date", /* The command string to type. */
    "\ndate:\n Print current date and time\n", 
    date, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/

static void vRegisterMyCLICommands(void) {
	/* Register all the command line commands defined immediately above. */
	FreeRTOS_CLIRegisterCommand(&xDiskInfo);
	FreeRTOS_CLIRegisterCommand(&xSetRTC);
	FreeRTOS_CLIRegisterCommand(&xDate);        
	FreeRTOS_CLIRegisterCommand(&xDie);
	FreeRTOS_CLIRegisterCommand(&xUnDie);
}

/* Start UART operation. */
void CLI_Start() {

//	vRegisterCLICommands();
	vRegisterFileSystemCLICommands();
	vRegisterMyCLICommands();
	{
		static StaticSemaphore_t xSemaphoreBuffer;
		xReceiveSemaphore = xSemaphoreCreateBinaryStatic(&xSemaphoreBuffer);
	}
    {
		static StackType_t xStack[643];
		static StaticTask_t xTaskBuffer;
		TaskHandle_t th = xTaskCreateStatic(UARTTask, "UART Task",
				sizeof xStack / sizeof xStack[0], 0, 3, xStack, &xTaskBuffer);
		configASSERT(th);
	}
    cy_en_scb_uart_status_t init_status = UART_1_Init(&UART_1_config);
    configASSERT(init_status == CY_SCB_UART_SUCCESS);
    UART_1_Enable();

    /* Unmasking only the RX fifo not empty interrupt bit */
    UART_1_HW->INTR_RX_MASK = SCB_INTR_RX_MASK_NOT_EMPTY_Msk;

    /* Interrupt Settings for UART */    
    Cy_SysInt_Init(&UART_1_SCB_IRQ_cfg, ISR_UART);

    /* Enable the interrupt */
    NVIC_EnableIRQ(UART_1_SCB_IRQ_cfg.intrSrc);

	/* Clear any pending interrupts */
	__NVIC_ClearPendingIRQ(UART_1_SCB_IRQ_cfg.intrSrc);

	printf("\033[2J\033[H"); // Clear Screen
    printDateTime();       
	printf("\nFree RTOS+CLI> ");
    fflush(stdout);
}


/* [] END OF FILE */
