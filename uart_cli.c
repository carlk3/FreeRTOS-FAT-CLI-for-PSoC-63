/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
 */

#include <stdio.h>
#include <string.h>

#include "project.h"

#include <FreeRTOS.h>
#include <task.h>
#include <semphr.h>

/* FreeRTOS+FAT includes. */
#include "ff_headers.h"
#include "ff_sddisk.h"
#include "ff_stdio.h"

#include "FreeRTOS_CLI.h"
#include "uart_cli.h"
#include "rtc.h"

/*
 * Register commands that can be used with FreeRTOS+CLI.
 * The commands are defined in CLI-commands.c and File-related-CLI-commands.c
 * respectively.
 */
extern void vRegisterCLICommands(void);
extern void vRegisterFileSystemCLICommands(void);

extern void run_ew_demo(void);
extern void Data_Logging_Start();

bool die_now = false; // Used outside here

static SemaphoreHandle_t xUartCountingSemaphore;

static void UART_handle_event(uint32_t event) {

	uint32_t rsta = Cy_SCB_UART_GetReceiveStatus(UART_1_HW, &UART_1_context);
	configASSERT(!rsta);

	if (CY_SCB_UART_RECEIVE_DONE_EVENT == event) {
		/* The xHigherPriorityTaskWoken parameter must be initialized to pdFALSE as
		 it will get set to pdTRUE inside the interrupt safe API function if a
		 context switch is required. */
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;

		configASSERT(xUartCountingSemaphore);

		BaseType_t rc = xSemaphoreGiveFromISR(xUartCountingSemaphore, &xHigherPriorityTaskWoken);
		configASSERT(rc == pdPASS);

		/* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR(). If
		 xHigherPriorityTaskWoken was set to pdTRUE inside vTaskNotifyGiveFromISR()
		 then calling portYIELD_FROM_ISR() will request a context switch. If
		 xHigherPriorityTaskWoken is still pdFALSE then calling
		 portYIELD_FROM_ISR() will have no effect. */
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

// uartTask - the function which handles input from the UART
// Note:
//   This initially used Task Notifications, 
//   but that caused a conflict with filesystem calls that also use Task Notifications.
static void uartTask(void *arg) {
	(void) arg;
	size_t cInputIndex = 0;
	static char cOutputString[cmdMAX_OUTPUT_SIZE] = { 0 };
	static char cInputString[cmdMAX_INPUT_SIZE] = { 0 };
	BaseType_t xMoreDataToFollow = 0;

	for (;;) {
		uint8_t cRxedChar;

		// Start a UART receive operation.
		// The element size is defined by the data type,
		//   which depends on the configured data width.
		cy_en_scb_uart_status_t usta = Cy_SCB_UART_Receive(UART_1_HW, &cRxedChar, 1, &UART_1_context);
		configASSERT(CY_SCB_UART_SUCCESS == usta);

		// Wait for interrupt:
		// BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );
		BaseType_t xStatus = xSemaphoreTake(xUartCountingSemaphore, portMAX_DELAY);
		configASSERT(xStatus == pdPASS);

		do { // Iterate until all pending notifications are cleared
			printf("%c", (int) cRxedChar); // echo
			fflush(stdout);

			/* Newline characters are taken as the end of the command
			 string. */
			if (cRxedChar == '\n' || cRxedChar == '\r') {
				TickType_t xStart = 0;
				/* Just to space the output from the input. */
				printf("\n");
				fflush(stdout);

				if (!strlen(cInputString)) { // Empty input
					printf("%s", pcEndOfOutputMessage);
					fflush(stdout);
					continue;
				}
				const char timestr[] = "time ";
				if (0 == strncmp(cInputString, timestr, 5)) {
					xStart = xTaskGetTickCount();
					strcpy(cInputString, cInputString + 5);
				}
				/* Process the input string received prior to the
				 newline. */
				do {
					/* Pass the string to FreeRTOS+CLI. */
					cOutputString[0] = 0x00;
					xMoreDataToFollow = FreeRTOS_CLIProcessCommand(cInputString, cOutputString, cmdMAX_OUTPUT_SIZE);

					/* Send the output generated by the command's
					 implementation. */
					printf("%s", cOutputString);
					fflush(stdout);

					/* Until the command does not generate any more output. */
				} while (xMoreDataToFollow);

				if (xStart) {
					fflush(stdout);
					printf("Time: %lu s\n", (unsigned long) (xTaskGetTickCount() - xStart) / configTICK_RATE_HZ);
				}
				/* All the strings generated by the command processing
				 have been sent.  Clear the input string ready to receive
				 the next command.  */
				cInputIndex = 0;
				memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);

				/* Transmit a spacer to make the console easier to
				 read. */
				fflush(stdout);
				printf("%s", pcEndOfOutputMessage);
				fflush(stdout);
			} else {
				if ((cRxedChar == '\b') || (cRxedChar == cmdASCII_DEL)) {
					/* Backspace was pressed.  Erase the last character
					 in the string - if any. */
					if (cInputIndex > 0) {
						cInputIndex--;
						cInputString[(int) cInputIndex] = '\0';
					}
				} else {
					/* A character was entered.  Add it to the string
					 entered so far.  When a \n is entered the complete
					 string will be passed to the command interpreter. */
					if (cInputIndex < cmdMAX_INPUT_SIZE - 1) {
						cInputString[(int) cInputIndex] = cRxedChar;
						cInputIndex++;
					} else {
						printf("\a[Input overflow!]\n");
						cInputString[cmdMAX_INPUT_SIZE - 1] = 0;
					}
				}
			}
		} while (pdPASS == xSemaphoreTake(xUartCountingSemaphore, 0));
	}
}

//static void handle_error(void) {
//	/* Disable all interrupts */
//	__disable_irq();
//
//	/* Switch on error LED */
////	Cy_GPIO_Write(Pin_LED_Red_0_PORT, LED9_0_NUM, 0);
//	CY_ASSERT(!"error");
//	Cy_SysLib_Halt(1);
//}
//

/*-----------------------------------------------------------*/
static BaseType_t die(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

	die_now = true;

	return pdFALSE;
}
static const CLI_Command_Definition_t xDie = { 
    "die", /* The command string to type. */
    "\ndie:\n Kill background tasks\n", 
    die, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/
static BaseType_t unDie(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

	die_now = false;

	return pdFALSE;
}
static const CLI_Command_Definition_t xUnDie = { 
    "undie", /* The command string to type. */
    "\nundie:\n Allow background tasks to live again\n", 
    unDie, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/
static BaseType_t setrtc(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;
	BaseType_t xParameterStringLength;

	const char *secStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	6, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(secStr);

	const char *minStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	5, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(minStr);

	const char *hourStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	4, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(hourStr);

	const char *yearStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	3, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(yearStr);

	const char *monthStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	2, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(monthStr);

	const char *dateStr = FreeRTOS_CLIGetParameter(pcCommandString, /* The command string itself. */
	1, /* Return the numbered parameter. */
	&xParameterStringLength /* Store the parameter string length. */
	);
	configASSERT(dateStr);

	SetDateTime(dateStr, monthStr, yearStr, secStr, minStr, hourStr);

	return pdFALSE;
}
static const CLI_Command_Definition_t xSetRTC = { 
    "setrtc", /* The command string to type. */
    "\nsetrtc <DD> <MM> <YY> <hh> <mm> <ss>:\n"
        "\tSet Real Time Clock\n"
		"\tParameters: new date (DD MM YY) new time in 24-hour format (hh mm ss)\n", 
    setrtc, /* The function to run. */
    6 /* parameters are expected. */
};
/*-----------------------------------------------------------*/
static BaseType_t date(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString) {
	(void) pcCommandString;
	(void) pcWriteBuffer;
	(void) xWriteBufferLen;

	PrintDateTime();

	return pdFALSE;
}
static const CLI_Command_Definition_t xDate = { 
    "date", /* The command string to type. */
    "\ndate:\n Print current date and time\n", 
    date, /* The function to run. */
    0 /* No parameters are expected. */
};
/*-----------------------------------------------------------*/


static void vRegisterMyCLICommands(void) {
	/* Register all the command line commands defined immediately above. */
	FreeRTOS_CLIRegisterCommand(&xDie);
	FreeRTOS_CLIRegisterCommand(&xUnDie);
	FreeRTOS_CLIRegisterCommand(&xSetRTC);
	FreeRTOS_CLIRegisterCommand(&xDate);    
}

/* Start UART operation. */
void CLI_Start() {
	BaseType_t rc = pdPASS;
	cy_en_scb_uart_status_t init_status = 0;

	vRegisterCLICommands();
	vRegisterFileSystemCLICommands();
	vRegisterMyCLICommands();

	xUartCountingSemaphore = xSemaphoreCreateCounting(16, 0);

	rc = xTaskCreate(uartTask, "UART Task", 1024, 0, 2, NULL);
	configASSERT(pdPASS == rc);

	init_status = Cy_SCB_UART_Init(UART_1_HW, &UART_1_config, &UART_1_context);
	configASSERT(init_status == CY_SCB_UART_SUCCESS);
	Cy_SCB_UART_RegisterCallback(UART_1_HW, UART_handle_event, &UART_1_context);

	/* Hook interrupt service routine for UART */
	cy_en_sysint_status_t stat = Cy_SysInt_Init(&UART_1_SCB_IRQ_cfg, UART_1_Interrupt);
	configASSERT(stat == CY_SYSINT_SUCCESS);

	/* Enable interrupt in NVIC */
	NVIC_EnableIRQ(UART_1_SCB_IRQ_cfg.intrSrc);
	/* Clear any pending interrupts */
	__NVIC_ClearPendingIRQ(UART_1_SCB_IRQ_cfg.intrSrc);

	Cy_SCB_UART_Enable(UART_1_HW);

	printf("\033[2J\033[H"); // Clear Screen
	printf("\nFree RTOS+CLI> ");
	fflush(stdout);

}

/* [] END OF FILE */
